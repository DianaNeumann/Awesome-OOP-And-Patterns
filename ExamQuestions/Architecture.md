 ## Architecture (Three-Tier Architecture)

- ### [A1] Какие слои присутствуют в классической 3х уровневой архитектуре. Дайте краткое описание и назначение каждого слоя.

> Тут сперва предлагаю рассказать, что вообще за "слоёность" и откуда это взялось.
> 
> Разделение кода на слои помогает раскладывать сложные системы на более простые части. Также каждый "промежуточный слой" скрывает нижний слой от верхнего.
> Нижние слое не осведомлены о налиичии верхних.
> 
> Такое расчленение системы имеет плюсы:
> - Можно воспринимать каждый отдельный слой как единое, самодостаточное целое, не заботясь об остальных слоях
> - Сведится к минимуму зависимость между слоями.
> - Нам ничего не мешает развернуть *([задеплоить](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D1%86%D0%B8%D0%B7%D0%BC%D1%8B))* много серверов с **Application слоем**
> - Базе данных не нужно устанавливать соединение с каждым клиентом - требуются соединения только с меньшим количеством серверов приложений (те самые серверы, на которых крутиться **Application слой**).
> - Защита целостности данных БД, ибо вся информация проходит через **Application слой**, который гарантирует надежность добавленных в БД данных
> - **Presentation слой** может кешировать запросы -> снижение нагрузки.
> 
> Но обладает и минусами:
> - Слои способны удачно инкапсулировать многое, но не всё: модификация одного слоя влечет за собой каскадные изменения в остальные слои. Пример: новое поле в БД (каскадное изменение бизнес-логики и представления)
> - Наличие избыточных слоёв нередко снижает производительность. Например, при переходе от слоя к слою, сущности подвергаются различных преобразованиям.  


> `Presentation Layer` - уровень, с которым непосредственно взаимодействуетпользователь. Этот уровень включает компоненты пользовательского интерфейса, механизм получения ввода от пользователя.

> `Application Layer` - содержит набор компонентов, которые отвечают за обработку полученных от уровня представлений данных, реализует всю необходимую логику приложения, все вычисления, взаимодействует с базой данных и передает уровню представления результат обработки.

> `Data Access Layer` - хранит модели, описывающие используемые сущности, также здесь размещаются специфичные классы для работы с разными технологиями доступа к данным, например, класс контекста данных Entity Framework. Здесь также хранятся репозитории, через которые уровень бизнес-логики взаимодействует с базой данных.

> PS: Иногда слова "layer" и "tier" употребляют как синонимы, но чаще всего, говоря "tier", подразумевают **физическое** разделение слоёв. То есть буквально, что каждый слой развернут на собственном сервере. 

---

- ### [A2] Какие обязанности берет на себя слой DAL? С какими слоями и как он связан?
> `DAL` - это слой, который отвечает за хранение данных.
>
>  Цель данного слоя - скрыть внутри себя все детали о том, как происходит работа с хранением данных, и предоставлять набор интерфейсов для BLL.

---

- ### [A3] Какие обязанности берет на себя слой BLL? С какими слоями и как он связан?
> `BLL` - слой бизнес логики. Тут содержится основной код нашего приложения.
> 
> • В контексте **анемичной модели** - сервисы, модели, ...
> 
> • В контексте **насыщенной модели** – сущности, агрегаты, ...
---

- ### [A4] Какие обязанности берет на себя слой Presentation? С какими слоями и как он связан?
> `Presentation` - это слой представления, слой, который отвечает за взаимодействие с пользователем.
>
> • чтения введённых данных от пользователя, её парсинг, а также вывод результатов на консоль
>
> • логика отрисовки окон, отображение данных и считывание их
> 
> • чтения запроса, его парсинг, вызов нужной логики и отправка нужного респонса

---

- ### [A5] Паттерны слоя DAL. Перечислить, дать краткое описание каждому, указать ключевые различия
> Ухххх, ну погнали.

> Существует 4 основных подхода для организации работы с базой данных: *Table Gateway*, *Row Data Gateway*, *Active Record* и *Data Mapper*. Все эти подходы объеденяет то, что они скрывают от нас базу данных и нюансы работы с ними.

> • `Table Data Gateway` - он же `Шлюз Таблицы Данных))` - класс, который является [Gateway](https://github.com/DianaNeumann/Awesome-OOP-And-Patterns/blob/main/ExamQuestions/Base.md#b9-gateway-%D0%B8-mapper-%D0%B2-%D1%87%D1%91%D0%BC-%D0%B8%D0%B4%D0%B5%D1%8F-%D0%B2-%D1%87%D1%91%D0%BC-%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D1%8F) для одной таблицы в базе данных. Один экземпляр работает со всеми строками в этой таблице. Его основное предназначение - спрятать SQL как деталь реализации, предоставиви простой CRUD интерфейс для работы с таблицами в соответствии с нуждами приложения. Поэтому и интерфейс его не должен быть особо сложным.
>
> Как правило, для каждой таблицы базы данных создается собственный Table Data Gateway.
>
> Также стоит помнить о том, что на наш запрос "найди в таблице записи с ключем X" шлюз может вернуть несколько записей. Поэтому интересной задачей является возврат результатов поиска в таблице. Варианты:
> 1) Тупо отобразить таблицу базу данных в какую-нибудь , типа **Map**. Тогда записи в таблице будет сопоставлен словарик с key-value. Такое себе решение.  
> 
> 2) **Data Transfer Object (DTO)** 
>
> 3) **Record Set** - структура данных, которая хранится в оперативной памяти и в точности напоминает результат выполнения SQL-запроса, однако может быть сгенерирована и использована другими частями системы. Говоря про record set, стоит упомянуть об одном моменте: **явный (aReservation.passenger)** и **неявный (aReservation ["passenger"])** интерфейс доступа к ним. Думаю минусы каждого подхода очевидны: при явном интерфейсе надо реализовывать отдельный класс с конкретными методами и атрибутами, а неявный интерфейс сам по себе говно. Я должен шестым чувством понять, что там именно "passanger", а не "client"? Да и слово pasanger я пишу в 50% случаев с ошибкой. К сожалению, именно неявный интерфейс более популярен.   
>
> 4) **Domain Object** - шлюз может также просто возвращать соответствующий объект из DAL. Создаст ли 
> то дополнительную двунаправленные зависимости между DAL и шлюзом? - Да. Критично ли это? - Фаулер говорит, что нет, ибо DAL и шлюз и так тесно связаны между собой. 
>
> ![image](https://user-images.githubusercontent.com/56086653/212489682-5b514452-e091-4d21-a4f6-b0b96375f243.png)

> • `Row Data Gateway` - класс, который является Gateway для одной строки в таблице базы данных. Один экземпляр работает со одной строкой в этой таблице.
> 
> Можно было бы конечно сделать объект, и держать логику хранения данных внутри. Но в таком случае у нас наши сущности будут зависеть от базы данных, и их будет не так уж легко тестировать. Тесты будут требовать подключения к базе данных и от того станут медленными.
> 
> Для решения этой проблемы, нам нужна прослойка между сущностью и базой данных. **Row Data Gateway**. При этом подходе мы проэцируем строки таблицы на объекты, которые служат промежуточным звеном и инкпсулируют все детали о том как сохраняется информация в себе. В итоге наши сущности могут работать через этот gateway используя штатные средства языка программирования.
>
> Когда использовать: вместе с **Transaction Script**, c Domain Model обычно **НЕ** используется 
>
> ![image](https://user-images.githubusercontent.com/56086653/212502351-c653f9f4-3c7a-46af-bb6b-2c402795f7a9.png)


> • `Active Record` - класс, который оборачивает строку в таблице базы данных, инкапсулирует доступ к базе данных и содержит бизнес-логику для этих данных.
>
> Очень похож на Row Data Gateway, разница в том, что active record содержит код бизнес-логики
>
>
> В основе active record лежит Domain Model, классы которой повторяют структуру записей используемой базы данных (также можно прокачаться паттерн и сделать отображение внешних ключей). 
> Каждый active record класс ответственен за сохранение и загрузку из базы данных, а также за бизнес-логику для этих (и только этих) данных.
> В целом, если доменная модель простая, то вся бизнес-логика приложение и может уместиться в active record. 
>
> Active record-классы довольно удобны с точки зрения разработчиков, ибо пользволяют писать меньше кода для отображения объектной моедли на БД, однако не позволяют полностью абстрагироваться БД.
> 
> Также, в отличии от "Row Data Mapper", в active record рекомендуется использовать статические методы поиска, которые находятся(в силу того, что active record классы тесно связаны с БД).
>
> Active record хорошо подходит для реализации не слишком сложной логики домена, в частности операций CRUD. Кроме того, она
прекрасно справляется с извлечением и проверкой на правильность отдельной записи
>
> Обычно обладает следующими видами методов:
> - Конструктор из строки-результата SQL запроса
> - Конструктор для последующего добавления в таблицу 
> - Update и Insert методы
> - Доступ к полям (свойства)
> - Методы бизнес-логики
> 
> Когда использовать: с не слишком сложной бизнес-логикой. Неплохо работает с **Transaction Script**, c простым Domain Model.
>
> ![image](https://user-images.githubusercontent.com/56086653/212570321-31c29c40-cf71-4b8a-afb1-a715099ba63b.png)


> • `Data Mapper` - набор классов Mapper, которые перемещают данные между объектами приложения и базой данных, не создавая зависимости между ними.
>
> В большинстве случаев **data mapper** применяется для того, чтобы схема БД и объектная модель могли изменяться независимо друг от друга. Как правило, подобная необходимость возникает при использовании доменной модели. Основным преимуществом преобразователя данных является возможность работы с моделью предметной области без учета структуры базы данных как в процессе проектирования, так и во время сборки и тестирования проекта. В этом случае объектам домена ничего не известно о структуре БД, поскольку все отображения выполняются преобразователями
>
> Изменение **domain model** не требует изменения структуры БД и наоборот, что крайне важно при наличии сложных отображений, особенно при использовании уже существующих баз данных
>
> Разумеется, за все удобства нужно платить. "Ценой" использования **data mapper'a** является необходимость реализации дополнительного слоя кода, чего можно избежать, применив **active record**. Поэтому основным критерием выбора того или иного типового решения является сложность бизнес-логики. Если бизнес-логика довольно проста, ее, скорее всего, можно реализовать и без применения **domain model или data mapper**. В свою очередь, реализация **более сложной** логики **НЕВОЗМОЖНА** без их использования :)
>
> На негодняшний день в чистом виде в рамках существующих ORM вы можете встретить только data mapper. ORM на основе active record так или иначе внутри используют намного более сложные концепции, дабы упростить разработчикам жизнь и снизить сложность.

> Ещё раз коротко про разницу: в рамках `Active Record`  мы работаем с объектами как отображением элементов нашей базы данных, как если бы у нас был прямой доступ к ним без SQL прослойки. В `Data Mapper` мы работаем исключительно с нашими объектами, которые лежат в памяти, и просим отдельную штуку (мэппер) что бы тот синхронизировал состояние объектов в памяти и в базе (сохранил состояние по сути).
>
> ![image](https://user-images.githubusercontent.com/56086653/212592591-8a6a6883-7317-4ac0-b995-d0beea470c6e.png)


---

- ### [A6] Паттерны слоя BLL. Перечислить, дать краткое описание каждому, указать ключевые различия
> • `Transaction Script` - простейший подход к описанию бизнес-логики
> 
> Транзакционный сценарий использует процедуры, которые получают на вход информацию от слоя представления, обрабатывают ее, проводя необходимые проверки и вычисления, сохраняют в базе данных и активизируют операции других систем. Затем процедура возвращает слою представления определенные данные, возможно, осуществляя вспомогательные операции для форматирования содержимого результата. Бизнес-логика в этом случае описывается набором процедур, по одной на каждую (составную) операцию, которую способно выполнять приложение.
>
> Замечу, что это не обязательно единый фрагмент кода. Код делится на подпрограммы, которые распределяются между различными сценариями транзакции.
>
> Например: пользователю необходимо заказать номер в гостинице, соответствующая процедура должна предусматривать действия по проверке наличия подходящего номера, вычислению суммы оплаты и фиксации заказа в базе данных
>
> Преимущества:
> - Простота
> - Определяет четкие границы транзакции
> - Удачно сочетается с **Table Data Gateway** и **Row Data Gateway**
>
> Недостатки:
> - При увеличении сложности бизнес-логики приводит к непомерному росту класса, дублированию кода

> • `Domain Model` - это самая ООПшное и самое базовое решение
>
> Выделяются объекты, соответствующие объектам предметной области. Описываются отношения между такими объектами, соответствующие отношениям между объектами реального мира
>
> Выделяют два варианта Domain Model:
> - **Anemic Domain Model** - в объектах предметной области инкапсулируются только данные, поведение же выносится в слой сервисов, расположенный поверх слоя предметной области
> - **Rich Domain Model** - данные и поведение инкапсулируются внутри объектов предметной области
>
> Сложная модель более адекватно представляет запутанную бизнес-логику, но труднее поддается отображению в реляционную схему базы данных. В простых моделях достаточно применять Active Record, в то время как в сложных без замысловатых Data Mapper'ов порой просто не обойтись

> • `Table Module` представляет собой "привлекательный островок вблизи экватора, разделяющего враждебные земли **Transaction Script** и **Domain Model**" (c). Он лучше справляется с представлением бизнес-логики, нежели **Transaction Script**
>
> Такой подход предусматривает создание по одному классу на каждую таблицу базы данных, и единственный экземпляр класса содержит всю логику
обработки данных таблицы.
>
> Основное отличие **Table Module** от **Domain Module** состоит в том, что если, например, приложение обслуживает множество заказов, в соответствии с domain model, придется сконструировать по одному объекту на каждый заказ, а при использовании table module понадобится всего один объект, представляющий одновременно все заказы.
>
> Класс **Table Module** во многом напоминает обычный объект, но отличается тем, что не содержит какого бы то ни было упоминания об идентификационном признаке объекта. Это значит, что если нам нужно узнать, в какой группе студент, для этого мы применим метод StudentModule.GetGroup(Guid StudentId). То есть, если нам необходимо выполнить операцию, касающуюся определенного студента, соответствующему методу следует передать ссылку на идентификатор, значение которого зачастую совпадает с первичным ключом студента в БД.
> 
> **Table Module**, как правило, отвечает некая табличная структура данных. Подобная информация обычно является результатом выполнения SQL-запроса и сохраняется в виде **Record Set**
>
> **Юзкейс-1 (похуже)**: 
> - Table Module (помимо данных и функций бизнес-логики) содержит статические методы, представляющие запросы к БД. Ну и таким способом ты работаем с БД, изменяем объекты и тд (всё в слое бизнес-логики)
>
> **Юзкейс-2 (получше)**: 
> - Использование **Table Data Gateway**. Table data gateway позволяет структурировать информацию в виде record set, которое затем передается конструктору table module в качестве аргумента. Если необходимо использовать несколько table module, все они могут быть созданы на основе одного и того же record set. Затем каждый table module применяет к record set функции бизнес-логики и передает измененное record set слою представления для отображения и редактирования. Последние не осведомлены, откуда поступили данные - непосредственно от реляционной СУБД или от промежуточного table module, который успел осуществить их предварительную обработку. По завершении редактирования, информация возвращается к table module для проверки перед сохранением в БД. Одно из преимуществ подобного стиля - возможность тестирования table module путем искусственного создания record set в памяти без обращения к реальной таблице БД.

---

- ### [A7] Паттерн Plugin. Описать идею, структуру, привести пример



