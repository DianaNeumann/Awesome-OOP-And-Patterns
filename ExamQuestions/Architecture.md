 ## Architecture (Three-Tier Architecture)

- ### [A1] Какие слои присутствуют в классической 3х уровневой архитектуре. Дайте краткое описание и назначение каждого слоя.

> Тут сперва предлагаю рассказать, что вообще за "слоёность" и откуда это взялось.
> 
> Разделение кода на слои помогает раскладывать сложные системы на более простые части. Также каждый "промежуточный слой" скрывает нижний слой от верхнего.
> Нижние слое не осведомлены о налиичии верхних.
> 
> Такое расчленение системы имеет плюсы:
> - Можно воспринимать каждый отдельный слой как единое, самодостаточное целое, не заботясь об остальных слоях
> - Сведится к минимуму зависимость между слоями.
> - Нам ничего не мешает развернуть *([задеплоить](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D1%86%D0%B8%D0%B7%D0%BC%D1%8B))* много серверов с **Application слоем**
> - Базе данных не нужно устанавливать соединение с каждым клиентом - требуются соединения только с меньшим количеством серверов приложений (те самые серверы, на которых крутиться **Application слой**).
> - Защита целостности данных БД, ибо вся информация проходит через **Application слой**, который гарантирует надежность добавленных в БД данных
> - **Presentation слой** может кешировать запросы -> снижение нагрузки.
> 
> Но обладает и минусами:
> - Слои способны удачно инкапсулировать многое, но не всё: модификация одного слоя влечет за собой каскадные изменения в остальные слои. Пример: новое поле в БД (каскадное изменение бизнес-логики и представления)
> - Наличие избыточных слоёв нередко снижает производительность. Например, при переходе от слоя к слою, сущности подвергаются различных преобразованиям.  


> `Presentation Layer` - уровень, с которым непосредственно взаимодействуетпользователь. Этот уровень включает компоненты пользовательского интерфейса, механизм получения ввода от пользователя.

> `Application Layer` - содержит набор компонентов, которые отвечают за обработку полученных от уровня представлений данных, реализует всю необходимую логику приложения, все вычисления, взаимодействует с базой данных и передает уровню представления результат обработки.

> `Data Access Layer` - хранит модели, описывающие используемые сущности, также здесь размещаются специфичные классы для работы с разными технологиями доступа к данным, например, класс контекста данных Entity Framework. Здесь также хранятся репозитории, через которые уровень бизнес-логики взаимодействует с базой данных.

> PS: Иногда слова "layer" и "tier" употребляют как синонимы, но чаще всего, говоря "tier", подразумевают **физическое** разделение слоёв. То есть буквально, что каждый слой развернут на собственном сервере. 

---

- ### [A2] Какие обязанности берет на себя слой DAL? С какими слоями и как он связан?
> `DAL` - это слой, который отвечает за хранение данных.
>
>  Цель данного слоя - скрыть внутри себя все детали о том, как происходит работа с хранением данных, и предоставлять набор интерфейсов для BLL.

---

- ### [A3] Какие обязанности берет на себя слой BLL? С какими слоями и как он связан?
> `BLL` - слой бизнес логики. Тут содержится основной код нашего приложения.
> 
> • В контексте **анемичной модели** - сервисы, модели, ...
> 
> • В контексте **насыщенной модели** – сущности, агрегаты, ...
---

- ### [A4] Какие обязанности берет на себя слой Presentation? С какими слоями и как он связан?
> `Presentation` - это слой представления, слой, который отвечает за взаимодействие с пользователем.
>
> • чтения введённых данных от пользователя, её парсинг, а также вывод результатов на консоль
>
> • логика отрисовки окон, отображение данных и считывание их
> 
> • чтения запроса, его парсинг, вызов нужной логики и отправка нужного респонса

---

- ### [A5] Паттерны слоя DAL. Перечислить, дать краткое описание каждому, указать ключевые различия
> Ухххх, ну погнали.

> Существует 4 основных подхода для организации работы с базой данных: *Table Gateway*, *Row Data Gateway*, *Active Record* и *Data Mapper*. Все эти подходы объеденяет то, что они скрывают от нас базу данных и нюансы работы с ними.

> • `Table Data Gateway` - он же `Шлюз Таблицы Данных))` - класс, который является [Gateway](https://github.com/DianaNeumann/Awesome-OOP-And-Patterns/blob/main/ExamQuestions/Base.md#b9-gateway-%D0%B8-mapper-%D0%B2-%D1%87%D1%91%D0%BC-%D0%B8%D0%B4%D0%B5%D1%8F-%D0%B2-%D1%87%D1%91%D0%BC-%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D1%8F) для одной таблицы в базе данных. Один экземпляр работает со всеми строками в этой таблице. Его основное предназначение - спрятать SQL как деталь реализации, предоставиви простой CRUD интерфейс для работы с таблицами в соответствии с нуждами приложения. Поэтому и интерфейс его не должен быть особо сложным.
>
> Как правило, для каждой таблицы базы данных создается собственный Table Data Gateway.
>
> Также стоит помнить о том, что на наш запрос "найди в таблице записи с ключем X" шлюз может вернуть несколько записей. Поэтому интересной задачей является возврат результатов поиска в таблице. Варианты:
> 1) Тупо отобразить таблицу базу данных в какую-нибудь простую структуру, типа *Map*. Тогда записи в таблице будет сопоставлен словарик с key-value. Такое себе решение.  
> 
> 2) Data Transfer Object
>
> 3) Полный Record Set
>
> 4) Domain object в случае Domain Model
>
> ![image](https://user-images.githubusercontent.com/56086653/212489682-5b514452-e091-4d21-a4f6-b0b96375f243.png)

> •

> •

> •


---

- ### [A6] Паттерны слоя BLL. Перечислить, дать краткое описание каждому, указать ключевые различия

---

- ### [A7] Паттерн Plugin. Описать идею, структуру, привести пример



