 ## Architecture (Three-Tier Architecture)

- ### [A1] Какие слои присутствуют в классической 3х уровневой архитектуре. Дайте краткое описание и назначение каждого слоя.

> Тут сперва предлагаю рассказать, что вообще за "слоёность" и откуда это взялось.
> 
> Разделение кода на слои помогает раскладывать сложные системы на более простые части. Также каждый "промежуточный слой" скрывает нижний слой от верхнего.
> Нижние слое не осведомлены о налиичии верхних.
> 
> Такое расчленение системы имеет плюсы:
> - Можно воспринимать каждый отдельный слой как единое, самодостаточное целое, не заботясь об остальных слоях
> - Сведится к минимуму зависимость между слоями.
> - Нам ничего не мешает развернуть *([задеплоить](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D1%86%D0%B8%D0%B7%D0%BC%D1%8B))* много серверов с **Application слоем**
> - Базе данных не нужно устанавливать соединение с каждым клиентом - требуются соединения только с меньшим количеством серверов приложений (те самые серверы, на которых крутиться **Application слой**).
> - Защита целостности данных БД, ибо вся информация проходит через **Application слой**, который гарантирует надежность добавленных в БД данных
> - **Presentation слой** может кешировать запросы -> снижение нагрузки.
> 
> Но обладает и минусами:
> - Слои способны удачно инкапсулировать многое, но не всё: модификация одного слоя влечет за собой каскадные изменения в остальные слои. Пример: новое поле в БД (каскадное изменение бизнес-логики и представления)
> - Наличие избыточных слоёв нередко снижает производительность. Например, при переходе от слоя к слою, сущности подвергаются различных преобразованиям.  


> `Presentation Layer` - уровень, с которым непосредственно взаимодействуетпользователь. Этот уровень включает компоненты пользовательского интерфейса, механизм получения ввода от пользователя.

> `Application Layer` - содержит набор компонентов, которые отвечают за обработку полученных от уровня представлений данных, реализует всю необходимую логику приложения, все вычисления, взаимодействует с базой данных и передает уровню представления результат обработки.

> `Data Access Layer` - хранит модели, описывающие используемые сущности, также здесь размещаются специфичные классы для работы с разными технологиями доступа к данным, например, класс контекста данных Entity Framework. Здесь также хранятся репозитории, через которые уровень бизнес-логики взаимодействует с базой данных.

> PS: Иногда слова "layer" и "tier" употребляют как синонимы, но чаще всего, говоря "tier", подразумевают **физическое** разделение слоёв. То есть буквально, что каждый слой развернут на собственном сервере. 

---

- ### [A2] Какие обязанности берет на себя слой DAL? С какими слоями и как он связан?
> `DAL` - это слой, который отвечает за хранение данных.
>
>  Цель данного слоя - скрыть внутри себя все детали о том, как происходит работа с хранением данных, и предоставлять набор интерфейсов для BLL.

---

- ### [A3] Какие обязанности берет на себя слой BLL? С какими слоями и как он связан?
> `BLL` - слой бизнес логики. Тут содержится основной код нашего приложения.
> 
> • В контексте **анемичной модели** - сервисы, модели, ...
> 
> • В контексте **насыщенной модели** – сущности, агрегаты, ...
---

- ### [A4] Какие обязанности берет на себя слой Presentation? С какими слоями и как он связан?
> `Presentation` - это слой представления, слой, который отвечает за взаимодействие с пользователем.
>
> • чтения введённых данных от пользователя, её парсинг, а также вывод результатов на консоль
>
> • логика отрисовки окон, отображение данных и считывание их
> 
> • чтения запроса, его парсинг, вызов нужной логики и отправка нужного респонса

---

- ### [A5] Паттерны слоя DAL. Перечислить, дать краткое описание каждому, указать ключевые различия
> Ухххх, ну погнали.

> Существует 4 основных подхода для организации работы с базой данных: *Table Gateway*, *Row Data Gateway*, *Active Record* и *Data Mapper*. Все эти подходы объеденяет то, что они скрывают от нас базу данных и нюансы работы с ними.

> • `Table Data Gateway` - он же `Шлюз Таблицы Данных))` - класс, который является [Gateway](https://github.com/DianaNeumann/Awesome-OOP-And-Patterns/blob/main/ExamQuestions/Base.md#b9-gateway-%D0%B8-mapper-%D0%B2-%D1%87%D1%91%D0%BC-%D0%B8%D0%B4%D0%B5%D1%8F-%D0%B2-%D1%87%D1%91%D0%BC-%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D1%8F) для одной таблицы в базе данных. Один экземпляр работает со всеми строками в этой таблице. Его основное предназначение - спрятать SQL как деталь реализации, предоставиви простой CRUD интерфейс для работы с таблицами в соответствии с нуждами приложения. Поэтому и интерфейс его не должен быть особо сложным.
>
> Как правило, для каждой таблицы базы данных создается собственный Table Data Gateway.
>
> Также стоит помнить о том, что на наш запрос "найди в таблице записи с ключем X" шлюз может вернуть несколько записей. Поэтому интересной задачей является возврат результатов поиска в таблице. Варианты:
> 1) Тупо отобразить таблицу базу данных в какую-нибудь , типа **Map**. Тогда записи в таблице будет сопоставлен словарик с key-value. Такое себе решение.  
> 
> 2) **Data Transfer Object (DTO)** 
>
> 3) **Record Set** - структура данных, которая хранится в оперативной памяти и в точности напоминает результат выполнения SQL-запроса, однако может быть сгенерирована и использована другими частями системы. Говоря про record set, стоит упомянуть об одном моменте: **явный (aReservation.passenger)** и **неявный (aReservation ["passenger"])** интерфейс доступа к ним. Думаю минусы каждого подхода очевидны: при явном интерфейсе надо реализовывать отдельный класс с конкретными методами и атрибутами, а неявный интерфейс сам по себе говно. Я должен шестым чувством понять, что там именно "passanger", а не "client"? Да и слово pasanger я пишу в 50% случаев с ошибкой. К сожалению, именно неявный интерфейс более популярен.   
>
> 4) **Domain Object** - шлюз может также просто возвращать соответствующий объект из DAL. Создаст ли 
> то дополнительную двунаправленные зависимости между DAL и шлюзом? - Да. Критично ли это? - Фаулер говорит, что нет, ибо DAL и шлюз и так тесно связаны между собой. 
>
> ![image](https://user-images.githubusercontent.com/56086653/212489682-5b514452-e091-4d21-a4f6-b0b96375f243.png)

> • `Row Data Gateway` - класс, который является Gateway для одной строки в таблице базы данных. Один экземпляр работает со одной строкой в этой таблице.
> 
> Можно было бы конечно сделать объект, и держать логику хранения данных внутри. Но в таком случае у нас наши сущности будут зависеть от базы данных, и их будет не так уж легко тестировать. Тесты будут требовать подключения к базе данных и от того станут медленными.
> 
> Для решения этой проблемы, нам нужна прослойка между сущностью и базой данных. **Row Data Gateway**. При этом подходе мы проэцируем строки таблицы на объекты, которые служат промежуточным звеном и инкпсулируют все детали о том как сохраняется информация в себе. В итоге наши сущности могут работать через этот gateway используя штатные средства языка программирования.
>
> Когда использовать: вместе с **Transaction Script**, c Domain Model обычно **НЕ** используется 
>
> ![image](https://user-images.githubusercontent.com/56086653/212502351-c653f9f4-3c7a-46af-bb6b-2c402795f7a9.png)


> • `Active Record` - класс, который оборачивает строку в таблице базы данных, инкапсулирует доступ к базе данных и содержит бизнес-логику для этих данных.
>
> Очень похож на Row Data Gateway, разница в том, что Active Record содержит код бизнес-логики
>
>
> В основе Active Record лежит Domain Model, классы которой повторяют структуру записей используемой базы данных (также можно прокачаться паттерн и сделать отображение внешних ключей). 
> Каждый класс Active Record ответственен за сохранение и загрузку из базы данных, а также за бизнес-логику для этих (и только этих) данных.
> В целом, если доменная модель простая, то вся бизнес-логика приложение и может уместиться в Active Record. 
> 
>
> Обычно обладает следующими видами методов:
> - Конструктор из строки-результата SQL запроса
> - Конструктор для последующего добавления в таблицу 
> - Update и Insert методы
> - Доступ к полям (свойства)
> - Методы бизнес-логики
> 
> Когда использовать: с не слишком сложной бизнес-логикой. Неплохо работает с **Transaction Script**, c простым Domain Model.

> • `Data Mapper` 


---

- ### [A6] Паттерны слоя BLL. Перечислить, дать краткое описание каждому, указать ключевые различия

---

- ### [A7] Паттерн Plugin. Описать идею, структуру, привести пример



